// Generated by LiveScript 1.3.1
/**
 * User: bulgakov
 * Date: 30.05.15
 * Time: 20:29
 */
(function(){
  var React, debugStylesMoving, releaseStylesMoving, debugStylesRemoving, releaseStylesRemovig, Clone, Clones, BlgList, exports;
  if (typeof require != 'undefined' && require !== null) {
    React = require('react');
  } else {
    React = this.React;
  }
  Array.prototype.map = function(f){
    var i$, len$, x, results$ = [];
    for (i$ = 0, len$ = this.length; i$ < len$; ++i$) {
      x = this[i$];
      results$.push(f(x));
    }
    return results$;
  };
  Array.prototype.map_ = function(f){
    var i$, len$, x;
    for (i$ = 0, len$ = this.length; i$ < len$; ++i$) {
      x = this[i$];
      f(x);
    }
  };
  debugStylesMoving = {
    'box-shadow': '0 0 0 1px #f00'
  };
  releaseStylesMoving = {};
  debugStylesRemoving = {
    'box-shadow': '0 0 0 1px #f0f'
  };
  releaseStylesRemovig = {};
  Clone = React.createClass({
    componentDidMount: function(){
      var node;
      node = $(this.getDOMNode());
      this.props.d.willIn(node.height());
      return node.css(import$(import$({
        position: 'absolute',
        opacity: 0
      }, this.props.d.stylesMoving), this.props.transite)).velocity({
        opacity: 1
      }, this.props.d.config.duration, this.props.d.config.easing);
    },
    componentWillUnmount: function(){
      var self, node;
      self = $(this.getDOMNode());
      this.props.d.willOut(self.height());
      node = self.clone().css(this.props.d.stylesRemoving).velocity({
        opacity: 0
      }, this.props.d.config.duration, this.props.d.config.easing, function(){
        return $(this).remove();
      });
      return $(this.props.d.portal).append(node);
    },
    componentWillReceiveProps: function(nextProps){
      if (nextProps.prev) {
        return $(this.getDOMNode()).css(nextProps.prev);
      }
    },
    componentDidUpdate: function(){
      var this$ = this;
      this.props.d.animStart();
      return $(this.getDOMNode()).velocity(this.props.transite, this.props.d.config.duration, this.props.d.config.easing, function(){
        return this$.props.d.animEnd();
      });
    },
    render: function(){
      return React.DOM.div({}, this.props.children);
    }
  });
  Clones = React.createClass({
    componentDidMount: function(){},
    render: function(){
      var this$ = this;
      return React.createElement('div', {
        className: "anicoll-floatings"
      }, Array.prototype.slice.apply(this.props.children).sort(function(a, b){
        return a.key < b.key && -1 || (a.key > b.key && 1 || 0);
      }).map(function(child){
        return React.createElement(Clone, {
          key: child.key,
          ref: child.key,
          transite: this$.props.positions[child.key],
          prev: this$.props.prevPositions[child.key],
          d: this$.props.d
        }, React.cloneElement(child, {
          key: 'c'
        }));
      }));
    }
  });
  BlgList = React.createClass({
    getInitialState: function(){
      var defaultClone;
      defaultClone = function(node){
        return this(node).clone();
      };
      this.config = {
        easing: function(x, t, b, c, d){
          return -c * (t /= d) * (t - 2) + b;
        },
        duration: 350,
        debug: false
      };
      return {
        animating: false
      };
    },
    componentDidMount: function(){
      var ref$;
      $(this.getDOMNode()).css({
        opacity: 1
      });
      ref$ = (this.portalNode = document.createElement('div')).style;
      ref$.left = 0;
      ref$.top = 0;
      ref$.opacity = 0;
      ref$.position = 'absolute';
      document.body.appendChild(this.portalNode);
      return this.renderClones({
        positions: this.getPositions(),
        children: this.props.children
      });
    },
    componentWillUnmount: function(){
      return document.body.removeChild(this.portalNode);
    },
    componentWillReceiveProps: function(nextProps){
      var this$ = this;
      if (nextProps.config) {
        ['duration', 'easing', 'debug'].map_(function(field){
          if (nextProps.config[field] != null) {
            this$.config[field] = nextProps.config[field];
          }
        });
      }
      return this.prepareAnimation();
    },
    componentDidUpdate: function(prevProps){
      return this.startAnimation();
    },
    showClones: function(visible){
      $(this.getDOMNode()).css({
        opacity: !visible && 1.0 || 0.0
      });
      return $(this.portalNode).css({
        opacity: visible && 1.0 || 0.0,
        'z-index': visible && 10 || -10
      });
    },
    prepareAnimation: function(){
      return this.prev = this.getPositions();
    },
    startAnimation: function(){
      var node, th, this$ = this;
      this.startedAnims = 0;
      this.renderClones({
        positions: this.getPositions(),
        prevPositions: this.prev,
        children: this.props.children
      }, function(){
        return this$.showClones(true);
      });
      if (this.heightDiff !== 0) {
        node = $(this.getDOMNode());
        th = node.height();
        if (this.heightDiff < 0) {
          return node.css({
            'min-height': th
          }).velocity({
            'min-height': th + this.heightDiff
          }, this.config.duration, this.config.easing, function(){
            return $(this).css({
              'min-height': ''
            });
          });
        } else {
          return node.css({
            'max-height': th
          }).velocity({
            'max-height': th + this.heightDiff
          }, this.config.duration, this.config.easing, function(){
            return $(this).css({
              'max-height': ''
            });
          });
        }
      }
    },
    finishAnimation: function(){
      return this.showClones(false);
    },
    getPositions: function(){
      var positions, i$, ref$, len$, ref, node, rect, computedStyle;
      positions = {};
      for (i$ = 0, len$ = (ref$ = this.props.children).length; i$ < len$; ++i$) {
        ref = ref$[i$].key;
        node = this.refs[ref].getDOMNode();
        rect = node.getBoundingClientRect();
        computedStyle = getComputedStyle(node);
        positions[ref] = {
          top: rect.top - parseInt(computedStyle.marginTop, 10),
          left: rect.left - parseInt(computedStyle.marginLeft, 10),
          width: rect.width,
          height: rect.height
        };
      }
      return positions;
    },
    animEnd: function(){
      if (--this.startedAnims === 0) {
        return this.finishAnimation();
      }
    },
    renderClones: function(props, cb){
      var this$ = this;
      this.startedAnims = 1;
      this.heightDiff = 0;
      return React.render(React.createElement(Clones, import$(import$({
        key: 'clones',
        d: {
          animStart: function(){
            ++this$.startedAnims;
          },
          animEnd: function(){
            this$.animEnd();
          },
          portal: this.portalNode,
          willIn: function(x){
            this$.heightDiff += x;
          },
          willOut: function(x){
            this$.heightDiff -= x;
          },
          config: this.config,
          stylesMoving: this.config.debug && debugStylesMoving || releaseStylesMoving,
          stylesRemoving: this.config.debug && debugStylesRemoving || releaseStylesRemovig
        }
      }, props), this.props)), this.portalNode, function(){
        if (typeof cb == 'function') {
          cb();
        }
        this$.animEnd();
      });
    },
    render: function(){
      return React.DOM.div({}, this.props.children.map(function(child){
        return React.createElement('div', {
          key: child.key,
          ref: child.key
        }, child);
      }));
    }
  });
  if (typeof exports != null) {
    if (typeof module != null && module.exports) {
      exports = module.exports = BlgList;
    }
    exports.Anicoll = BlgList;
  } else {
    this.Anicoll = BlgList;
  }
  if (deepEq$(typeof define, 'function', '===') && define.amd) {
    define('Anicoll', [], function(){
      return BlgList;
    });
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
  function deepEq$(x, y, type){
    var toString = {}.toString, hasOwnProperty = {}.hasOwnProperty,
        has = function (obj, key) { return hasOwnProperty.call(obj, key); };
    var first = true;
    return eq(x, y, []);
    function eq(a, b, stack) {
      var className, length, size, result, alength, blength, r, key, ref, sizeB;
      if (a == null || b == null) { return a === b; }
      if (a.__placeholder__ || b.__placeholder__) { return true; }
      if (a === b) { return a !== 0 || 1 / a == 1 / b; }
      className = toString.call(a);
      if (toString.call(b) != className) { return false; }
      switch (className) {
        case '[object String]': return a == String(b);
        case '[object Number]':
          return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
        case '[object Date]':
        case '[object Boolean]':
          return +a == +b;
        case '[object RegExp]':
          return a.source == b.source &&
                 a.global == b.global &&
                 a.multiline == b.multiline &&
                 a.ignoreCase == b.ignoreCase;
      }
      if (typeof a != 'object' || typeof b != 'object') { return false; }
      length = stack.length;
      while (length--) { if (stack[length] == a) { return true; } }
      stack.push(a);
      size = 0;
      result = true;
      if (className == '[object Array]') {
        alength = a.length;
        blength = b.length;
        if (first) {
          switch (type) {
          case '===': result = alength === blength; break;
          case '<==': result = alength <= blength; break;
          case '<<=': result = alength < blength; break;
          }
          size = alength;
          first = false;
        } else {
          result = alength === blength;
          size = alength;
        }
        if (result) {
          while (size--) {
            if (!(result = size in a == size in b && eq(a[size], b[size], stack))){ break; }
          }
        }
      } else {
        if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) {
          return false;
        }
        for (key in a) {
          if (has(a, key)) {
            size++;
            if (!(result = has(b, key) && eq(a[key], b[key], stack))) { break; }
          }
        }
        if (result) {
          sizeB = 0;
          for (key in b) {
            if (has(b, key)) { ++sizeB; }
          }
          if (first) {
            if (type === '<<=') {
              result = size < sizeB;
            } else if (type === '<==') {
              result = size <= sizeB
            } else {
              result = size === sizeB;
            }
          } else {
            first = false;
            result = size === sizeB;
          }
        }
      }
      stack.pop();
      return result;
    }
  }
}).call(this);
